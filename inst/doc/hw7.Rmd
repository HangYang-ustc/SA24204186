---
title: "hw7"
author: "阳航"
date: "2024-12-08"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to R-package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
11.3 (a) 编写函数计算第k项
```{r}
library(gsl)  # 用于Gamma函数

# 定义函数来计算第 k 项
compute_term <- function(k, a, d) {
  norm_a <- sqrt(sum(a^2))
  term <- ((-1)^k / (factorial(k) * 2^k)) * (norm_a^(2 * k + 2) / ((2 * k + 1) * (2 * k + 2))) *
          (gamma((d + 1) / 2) * gamma(k + 1.5) / gamma(k + d / 2 + 1))
  return(term)
}

# 测试计算第 k 项
k <- 0  # 可以改变 k 值来测试不同项
a <- c(1, 2)  # 向量 a
d <- length(a)  # 维度 d
compute_term(k, a, d)

```
11.3 (b) 编写函数计算整个和
```{r}
compute_sum <- function(a, d, k_max = 100) {
  sum_result <- 0
  for (k in 0:k_max) {
    sum_result <- sum_result + compute_term(k, a, d)
  }
  return(sum_result)
}

# 测试计算和
a <- c(1, 2)
d <- length(a)
compute_sum(a, d)

```
11.3 (c)
```{r}
# 使用已定义的函数 compute_sum 计算在 a = (1, 2)^T 的情况下的级数和
a <- c(1, 2)
d <- length(a)
sum_result <- compute_sum(a, d)

# 输出结果
sum_result

```
11.5 编写求解方程的函数
```{r}
library(pracma)  # 用于数值积分
library(gsl)     # 用于Gamma函数

# 定义函数来计算积分
compute_integral <- function(upper_limit, k, exponent) {
  integrand <- function(u) {
    (1 + u^2 / k)^(-exponent)
  }
  integral_result <- integrate(integrand, lower = 0, upper = upper_limit)$value
  return(integral_result)
}
# 定义函数来计算 c_k 值
compute_ck <- function(k, a) {
  c_k <- sqrt((a^2 * k) / (k + 1 - a^2))
  return(c_k)
}

compute_ck_minus_1 <- function(k, a) {
  c_k_minus_1 <- sqrt((a^2 * (k - 1)) / (k - 1 - a^2))
  return(c_k_minus_1)
}
# 定义详细的 solve_equation_details 函数
solve_equation_details <- function(k, a) {
  # 计算 c_{k-1} 和 c_k
  c_k_minus_1 <- compute_ck_minus_1(k, a)
  c_k <- compute_ck(k, a)
  
  # 计算方程左侧的积分和常数项
  left_term_constant <- (2 * gamma(k / 2)) / (sqrt(pi * (k - 1)) * gamma((k - 1) / 2))
  left_term_integral <- compute_integral(c_k_minus_1, k - 1, k / 2)
  left_term <- left_term_constant * left_term_integral
  
  # 计算方程右侧的积分和常数项
  right_term_constant <- (2 * gamma((k + 1) / 2)) / (sqrt(pi * k) * gamma(k / 2))
  right_term_integral <- compute_integral(c_k, k, (k + 1) / 2)
  right_term <- right_term_constant * right_term_integral
  
  # 返回左右两侧的值以及差值
  difference <- left_term - right_term
  return(list(left_term = left_term, right_term = right_term, difference = difference))
}

```
与11.4比较
```{r}
# 计算11.4中的曲线阈值
compute_threshold_11_4 <- function(k, a) {
  threshold_k_minus_1 <- sqrt(a^2 * (k - 1) / (k - a^2))
  threshold_k <- sqrt(a^2 * k / (k + 1 - a^2))
  return(list(threshold_k_minus_1 = threshold_k_minus_1, threshold_k = threshold_k))
}
# 比较11.4和11.5的函数
compare_11_4_and_11_5 <- function(k_values, a) {
  results <- data.frame(
    k = k_values,
    threshold_k_minus_1 = NA,
    threshold_k = NA,
    left_term = NA,
    right_term = NA,
    difference = NA
  )
  
  for (i in 1:length(k_values)) {
    k <- k_values[i]
    
    # 计算11.4中的阈值
    thresholds <- compute_threshold_11_4(k, a)
    results$threshold_k_minus_1[i] <- thresholds$threshold_k_minus_1
    results$threshold_k[i] <- thresholds$threshold_k
    
    # 计算11.5中的方程解
    equation_result <- solve_equation_details(k, a)
    results$left_term[i] <- equation_result$left_term
    results$right_term[i] <- equation_result$right_term
    results$difference[i] <- equation_result$difference
  }
  
  return(results)
}
# 测试比较
k_values <- c(4, 25, 100, 500, 1000)
a <- 0.5
comparison_results <- compare_11_4_and_11_5(k_values, a)

# 输出比较结果
print(comparison_results)


```
使用 E-M 算法估计参数 λ
```{r}
# 初始化观测数据
Y <- c(0.54, 0.48, 0.33, 0.43, 1.00, 1.00, 0.91, 1.00, 0.21, 0.85)
tau <- 1.0  # 右删失阈值

# 分离被删失的数据和非删失的数据
Y_observed <- Y[Y < tau]
Y_censored <- Y[Y == tau]

# 初始化参数 lambda
lambda <- 1.0  # 可以选择一个合理的初始值
tolerance <- 1e-6  # 收敛条件
max_iter <- 1000  # 最大迭代次数

# E-M 算法
for (iter in 1:max_iter) {
  # 计算 E 步中的期望
  expected_censored <- tau + 1 / lambda
  
  # M 步：更新 lambda
  lambda_new <- length(Y) / (sum(Y_observed) + length(Y_censored) * expected_censored)
  
  # 检查收敛
  if (abs(lambda_new - lambda) < tolerance) {
    break
  }
  
  # 更新 lambda
  lambda <- lambda_new
}

# 输出最终的 lambda 值
cat("E-M 算法估计的 lambda:", lambda, "\n")

# 与 MLE 进行比较
lambda_mle <- length(Y) / sum(Y)
cat("MLE 估计的 lambda:", lambda_mle, "\n")

```

