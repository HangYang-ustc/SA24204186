---
title: "hw8"
author: "阳航"
date: "2024-12-08"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to R-package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

11.7
```{r}
# 如果尚未安装 lpSolve 包，请先安装
if (!require("lpSolve")) {
  install.packages("lpSolve")
}

# 加载 lpSolve 包
library(lpSolve)

# 目标函数系数 (最小化 4x + 2y + 9z)
objective <- c(4, 2, 9)

# 约束条件的系数矩阵
constraints <- matrix(c(2, 1, 1,  # 2x + y + z
                        1, -1, 3), # x - y + 3z
                      nrow = 2, byrow = TRUE)

# 约束条件右侧的值
rhs <- c(2, 3)

# 约束条件方向
directions <- c("<=", "<=")

# 求解线性规划问题
solution <- lp("min", objective, constraints, directions, rhs, compute.sens = TRUE)

# 输出结果
cat("最优解为：\n")
print(solution$solution)

cat("\n目标函数的最小值为：\n")
print(solution$objval)

cat("\n灵敏度分析结果：\n")
print(solution$sens.coef.from)
print(solution$sens.coef.to)

```
R advance 3.4.5
```{r}

#第3题：使用 for 循环和 lapply() 拟合线性模型
# 定义公式列表
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)

# 使用 for 循环拟合模型
models_for <- list()
for (i in seq_along(formulas)) {
  models_for[[i]] <- lm(formulas[[i]], data = mtcars)
}

# 使用 lapply 拟合模型
models_lapply <- lapply(formulas, function(f) lm(f, data = mtcars))

#第4题：对bootstrap replicates拟合模型
# 创建 bootstrap 样本
bootstraps <- lapply(1:10, function(i) {
  rows <- sample(1:nrow(mtcars), size = nrow(mtcars), replace = TRUE)
  mtcars[rows, ]
})

# 使用 for 循环拟合 mpg ~ disp 的模型
models_boot_for <- list()
for (i in seq_along(bootstraps)) {
  models_boot_for[[i]] <- lm(mpg ~ disp, data = bootstraps[[i]])
}

# 使用 lapply 拟合 mpg ~ disp 的模型（不使用匿名函数）
fit_model <- function(data) {
  lm(mpg ~ disp, data = data)
}
models_boot_lapply <- lapply(bootstraps, fit_model)

#第5题：提取每个模型的r方值
# 定义提取 R^2 的函数
rsq <- function(mod) summary(mod)$r.squared

# 提取第3题中所有模型的 R^2
r2_for <- sapply(models_for, rsq)
r2_lapply <- sapply(models_lapply, rsq)

# 提取第4题中 bootstrap 模型的 R^2
r2_boot_for <- sapply(models_boot_for, rsq)
r2_boot_lapply <- sapply(models_boot_lapply, rsq)

# 输出 R^2 值
cat("第3题（for 循环）模型的 R^2：\n")
print(r2_for)
cat("\n第3题（lapply）模型的 R^2：\n")
print(r2_lapply)

cat("\n第4题（bootstrap for 循环）模型的 R^2：\n")
print(r2_boot_for)
cat("\n第4题（bootstrap lapply）模型的 R^2：\n")
print(r2_boot_lapply)

```
213 第3题：使用 sapply() 提取 p 值
```{r}
# 模拟 100 次 t 检验
trials <- replicate(
  100,
  t.test(rpois(10, 10), rpois(7, 10)),
  simplify = FALSE
)

# 使用匿名函数提取每次试验的 p 值
p_values_anonymous <- sapply(trials, function(x) x$p.value)

# 挑战：直接使用 [[ 提取 p 值
p_values_direct <- sapply(trials, `[[`, "p.value")

# 输出 p 值
cat("使用匿名函数提取的 p 值：\n")
print(p_values_anonymous)

cat("\n直接使用 [[ 提取的 p 值：\n")
print(p_values_direct)

```
213 第6题：实现一个基于 Map() 和 vapply() 的并行迭代函数
```{r}
# 定义并行迭代函数
parallel_apply <- function(FUN, ..., output_type = "vector") {
  # 使用 Map 并行迭代所有输入
  results <- Map(FUN, ...)
  
  # 根据输出类型存储结果
  if (output_type == "vector") {
    return(vapply(results, identity, FUN.VALUE = integer(1)))  # 确保返回值为整数
  } else if (output_type == "matrix") {
    return(do.call(rbind, results))
  } else {
    stop("Unsupported output_type. Use 'vector' or 'matrix'.")
  }
}

# 示例测试
x <- 1:5
y <- 6:10

example_function <- function(a, b) a + b

# 并行迭代并输出为向量
vector_output <- parallel_apply(example_function, x, y, output_type = "vector")
cat("向量输出：\n")
print(vector_output)

# 并行迭代并输出为矩阵
matrix_output <- parallel_apply(example_function, x, y, output_type = "matrix")
cat("\n矩阵输出：\n")
print(matrix_output)

```
365第4题：优化版的 chisq.test()
```{r}
# 定义快速版 chisq.test，只计算卡方统计量
fast_chisq_test <- function(x, y) {
  # 检查输入是否为数值向量且无缺失值
  if (!is.numeric(x) || !is.numeric(y) || any(is.na(x)) || any(is.na(y))) {
    stop("Input must be two numeric vectors with no missing values.")
  }
  
  # 生成列联表
  observed <- table(x, y)
  
  # 计算期望值
  expected <- rowSums(observed) %o% colSums(observed) / sum(observed)
  
  # 计算卡方统计量
  chisq_stat <- sum((observed - expected)^2 / expected)
  
  return(chisq_stat)
}

# 测试快速版 chisq.test
x <- c(1, 2, 1, 2, 1, 3, 3, 2, 3, 1)
y <- c(1, 1, 2, 2, 2, 1, 3, 3, 3, 2)
fast_chisq_test(x, y) # 返回卡方统计量

```
365第5题：优化版的 table()
```{r}
# 定义快速版 table
fast_table <- function(x, y) {
  # 检查输入是否为整数向量且无缺失值
  if (!is.integer(x) || !is.integer(y) || any(is.na(x)) || any(is.na(y))) {
    stop("Input must be two integer vectors with no missing values.")
  }
  
  # 找到唯一值
  levels_x <- sort(unique(x))
  levels_y <- sort(unique(y))
  
  # 初始化结果矩阵
  result <- matrix(0, nrow = length(levels_x), ncol = length(levels_y),
                   dimnames = list(levels_x, levels_y))
  
  # 填充矩阵
  for (i in seq_along(x)) {
    result[as.character(x[i]), as.character(y[i])] <- result[as.character(x[i]), as.character(y[i])] + 1
  }
  
  return(result)
}

# 测试快速版 table
x <- as.integer(c(1, 2, 1, 2, 1, 3, 3, 2, 3, 1))
y <- as.integer(c(1, 1, 2, 2, 2, 1, 3, 3, 3, 2))
fast_table(x, y) # 返回列联表

```

